---
title: "Task1-5"
author: "Roman Havrylenko"
date: "10/01/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Question 1 Atomic Types

Create the following variables related to your chosen object:

4 numeric values (e.g., population, temperature, size, rating)
3 integer values (e.g., number of moons, buildings, inhabitants)
2 logical values (e.g., has_water, is_inhabited)
3 character values (e.g., name, region, category)

My object is Poltava city

```{r}
# code for solving task

#numeric
temperature <- 14.3
meters_above_sea_level <- 140.0
auto <- 285.000
highest_building <- 44.0


# integer

population <- 279593
area <- 103 #m2
shoppin_mall <- 3

#logical

has_water <-TRUE
has_autobus_station <- TRUE

#character

name <- 'Poltava'
region <- 'Poltavsky'
category <- 'city'

```


## Question 2 Vectors

Question description

Create three different vectors:

Numeric vector combining all your numeric and integer variables.
(Use c().)

Sequence vector from any number between 10–50 to 100, Choose step between 2 and 10.
(Use seq() or :.)

Logical vector of length 10 with random TRUE/FALSE values using sample().

```{r}
# code for solving task
vec <- c(temperature, meters_above_sea_level, auto, highest_building, population, area, shoppin_mall)

vec

vec_seq <- seq( from = 20, to = 100, by = 6)
vec_seq
  
vec_log <- sample(c(TRUE, FALSE), 10, replace = TRUE)
vec_log
```
## Question 3 Marix

Question description

Create a 3×3 matrix with random numbers between -50 and 50
(using sample() or runif()), and name its rows and columns according to your theme.

Then calculate row and column averages using rowMeans() and colMeans().
 


```{r}
 # code for solving task
m <- matrix(sample(-50:50, 9), nrow = 3, ncol = 3)
m

rowMeans(m)

colMeans(m)
```
## Question 4 List

Question description

Create a list that combines all your previous objects:
atomic variables, vectors, and matrix. Add one extra element — a short description of your universe as a string.


```{r}
# code for solving task
list <- list(auto, name, area, has_water, vec, m)
list
```
## Question 5 Factor

Question description

Create a factor variable representing categories within your universe, e.g.:

```{r}
# code for solving task

my_factor <- factor(c("big", "big", "small", "medium", "small"), levels = c("small", "medium", "big"))
my_factor
```
## Question 6 Data Frame

Question description

Create a data frame related to your object that includes:

5–8 observations (rows)
At least 3 columns of different data types
(e.g., name, numeric value, logical flag, category)
Then:

Rename the columns using names() or colnames().
Display its structure with str() and its summary with summary().
Add a new column derived from the others (for example, a ratio or condition).

```{r}
data <- data.frame(name=c("centr","podol", "almaznyj", "levada", "mala_scena"), numeric = c(16.4, 14.6, 25.7, 25.1, 18.2), logical = c(T, F, F, T, T), category = c("big", "small", "medium", "medium", "small"))

colnames(data) <- c("name", "size", "has_mall", "size")

data

str(data)

summary(data)

data$size_ratio <- data$size / max(data$size)

data

```
Task 2
2.1. Querying Vectors
Let’s start with the vectors you created in Task 1.

2.1.1. From your Sequence vector (the one with all your numbers):

Select and print the 3rd element.
Select and print elements 2 through 5.
Select and print all values that are greater than 20 (or another number that makes sense for your data).
2.1.2. From your Logical vector:

Select and print only the TRUE values. (Hint: your_vector[your_vector]).
Use which() to get the indices (positions) of all the TRUE values.
```{r}

vec_seq[3]
vec_seq[2:5]
vec_seq[vec_seq > 20]

vec_log[vec_log]
which(vec_log)
```
2.3. Investigating Your Data Frame
Use the data frame you created in Task 1.

Print the first 3 rows. (Use head().)
Print the value from the 4th row, 1st column.
Print only the column that contains your logical values (e.g., is_habitable) as a vector.
Logical Subsetting: Create a new data frame df_subset that contains only the rows that meet a specific logical condition.

Example: df_subset <- your_df[your_df$population > 1000, ]
%in% Subsetting: Create a new data frame df_subset_2 that selects rows belonging to two specific categories from your factor or character column.

Example: df_subset_2 <- your_df[your_df$region %in% c("North", "South"), ]
```{r}

head(data, 3)


data [4, 1]

data$has_mall


df_subset <- data[data$size > 20, ]
df_subset


df_subset_2 <- data[data$category %in% c("small", "medium"), ]
df_subset_2

```
2.4. Handling “Corrupted” Data (NA)
Create a copy of your original data frame (e.g., df_corrupted <- your_df).

Introduce 3 NAs into your df_corrupted at specific locations.

Example: df_corrupted[2, 3] <- NA
Find NAs:

Use sum(is.na(df_corrupted)) to find the total number of missing values.
Use colSums(is.na(df_corrupted)) to see how many NAs are in each column.
Calculate with NAs:

Calculate the mean() of the numeric column where you added an NA.
Filter NAs:

Use na.omit(df_corrupted) to create a new, “clean” data frame that contains only the complete rows.
```{r}

df_corrupted <- data

df_corrupted[2, 2] <- NA
df_corrupted[5, 3] <- NA
df_corrupted[3, 4] <- NA

df_corrupted

sum(is.na(df_corrupted))
colSums(is.na(df_corrupted))

mean(df_corrupted$size)
mean(df_corrupted$size, na.rm = TRUE)

df_clean <- na.omit(df_corrupted)
df_clean

```
2.5. Bonus Challenge: which()
Use which.max() or which.min() to find the row number (index) of the observation with the highest or lowest value in one of your numeric columns.

Use that index to print the row with that observation.

Example: highest_pop_index <- which.max(your_df$population)
Example: your_df[highest_pop_index, ]
```{r}
highest_size_index <- which.max(data$size)
data[highest_size_index, ]

lowest_size_index <- which.min(data$size)
data[lowest_size_index, ]

```
3.1. The Quest: Find Your Data
Find one simple, real-world dataset that fits your theme.

Where to look: Kaggle, TidyTuesday, data.gov, or other public data portals.

Format: Any format you are able to read. For simplicity it is proposed to use textual (csv, txt) or Excel format.

Requirements:

At least 50 rows.

At least 4 columns.

A mix of numeric and character/factor data.

Action:

Download the data file and place it in your R project directory.

In your task file add a line with the link to the data source (e.g., Data from: https://…).
```{r}
# Data from: https://www.kaggle.com/datasets/dgomonov/new-york-city-airbnb-open-data
```
3.2. The Import: Load Your Data

Install tidyverse: If you haven’t, run install.packages("tidyverse") in your console (just once).

Load libraries: At the top of your script, add library(dplyr) and library(readr) (library(readxl) in case of Excel file format).

Read the data: Use read_csv() (or read_excel()) to load your dataset into a new data frame.

# Load the Tidyverse libraries
library(dplyr)
library(readr)

# Load your data 
data <- read_csv("AB_NYC_2019.csv")

First Inspection: Immediately after loading, inspect your data to make sure it loaded correctly.
# See the structure and column types
glimpse(data)

# See the first 6 rows
head(data)

# Get a statistical summary
summary(data)
```{r}
# Install (only once)
# install.packages("tidyverse")

library(dplyr)
library(readr)

# Load dataset 
data <- read_csv("AB_NYC_2019.csv")

# First inspection
glimpse(data)
head(data)
summary(data)
```
3.3. The Interrogation: Explore with dplyr
This is the core of the task. Your goal is to ask and answer 5 interesting questions about your new dataset.

You must write the question in plain English (as a comment), followed by the dplyr code that answers it.

You must use each of the following dplyr “verbs” at least once:

select() - To pick specific columns.

filter() - To subset rows based on a condition.

arrange() - To sort your results (e.g., with desc()).

mutate() - To create a new column.

group_by() and summarise() - To get summary statistics (like mean(), n(), max(), etc.).
```{r}
# Question 1:
# Which neighbourhood groups have the highest average price?
data %>% 
  group_by(neighbourhood_group) %>% 
  summarise(avg_price = mean(price, na.rm = TRUE)) %>% 
  arrange(desc(avg_price))
```


```{r}
# Question 2:
# Which 10 ads are the most expensive?
data %>% 
  select(name, host_id, neighbourhood, price) %>% 
  arrange(desc(price)) %>% 
  head(10)
```

```{r}
# Question 3:
# How many listings are there for each room type (room_type)?
data %>% 
  group_by(room_type) %>% 
  summarise(count = n())
```
```{r}
# Question 4:
# Add a new column “price_per_minimum_stay” = price / minimum_nights.
# Show the first 10 rows.
data %>% 
  filter(minimum_nights > 0, price > 0) %>% 
  mutate(price_per_minimum_stay = price / minimum_nights) %>% 
  select(name, neighbourhood_group, price, minimum_nights, price_per_minimum_stay) %>% 
  head(10)
```
```{r}
# Question 5:
# Filter: listings in Manhattan over $200 with a minimum of 3 nights.
data %>% 
  filter(neighbourhood_group == "Manhattan",
         price > 200,
         minimum_nights >= 3) %>% 
  select(name, neighbourhood, price, minimum_nights)
```
Task 4. Building a “Toolkit” for Your Universe (Functions)

4.1. The “Greeting” Function (A Simple Start)
Let’s start with the basics. Write a simple function that prints a welcome message for your “universe”.

Write the function: It should take at least one argument (e.g., your_name or universe_name).

Inside the function: Use print() or cat() to display a message.

Call the function: After you define the function, you must call it to see the result.
```{r}
welcome_to_my_universe <- function(Roman) {
  cat("------------------------------------\n")
  cat("Analysis Toolkit for PPFK\n")
  cat("Report prepared by: Roman \n")
  cat("------------------------------------\n")
}

# Вызов
welcome_to_my_universe("PPFK")

```
4.2. The “Loading” Function (A Good Practice)
In Task 3, you wrote code to load and inspect your data. Let’s turn that into a function. This is a very common and useful practice.

Write the function: Name it load_and_inspect. It should take one argument: file_path.

Inside the function:

Load the readr and dplyr libraries.

Use read_csv(file_path) to load the data.

Print a message (e.g., “Data loaded successfully.”).

Print the glimpse() of the data.

Print the head() of the data.

Return the data frame (use the return() command).

Call the function:
```{r}
library(readr)
library(dplyr)

load_and_inspect <- function(file_path) {
  
  data <- read_csv(file_path)
  
  cat("\n✔ Data Loaded:", file_path, "\n")
  print(glimpse(data))
  
  cat("\n--- First 6 rows ---\n")
  print(head(data))
  
  return(data)
}

# Call the function, saving its output to a variable
data <- load_and_inspect("C:/Users/roomg/OneDrive/Рабочий стол/AB_NYC_2019.csv")

```
4.3. The “Query” Function (The Core of the Task)
This is the most important step. You will turn one of your dplyr queries from Task 3 into a reusable function.

Look back at your Task 3 code. You probably wrote something like this:

data |> filter(population > 1000000)

data |> filter(planet_type == "Gas Giant")

That 1000000 or “Gas Giant” is a “magic number” or “magic string”. A function lets you turn it into a parameter.

Choose a query: Pick one of your filter() or summarise() queries from Task 3.

Write the function:

Give it a descriptive name (e.g., find_pollution_by_disctrict, filter_cities_by_population).

It must take at least two arguments: data (for the data frame) and a parameter for the value you want to change (e.g., pop_threshold or type_name).

The function should perform the dplyr query and return the result.
```{r}
filter_by_area_and_price <- function(data, area_name, max_price) {
  
  result <- data |>
    filter(neighbourhood_group == area_name) |>
    filter(price <= max_price)
  
  return(result)
}

cheap_manhattan <- filter_by_area_and_price(data, "Manhattan", 100)

print(cheap_manhattan)

```
4.4. The “Reporting” Function
Let’s combine everything. Write a single function that calculates several key statistics for a specific group or category in your data.

Write the function: Name it generate_report. It should take data and a category_name as arguments (e.g., a specific city, planet type, or region).

Inside the function:

filter() your data for only the category_name provided.

Calculate 3-4 interesting summary statistics (e.g., mean(), max(), min(), n()).

Use cat() to print a nicely formatted “report” to the console.
```{r}
generate_report <- function(data, area_name) {
  
  area_data <- data |>
    filter(neighbourhood_group == area_name)
  
  n_listings <- nrow(area_data)
  avg_price <- mean(area_data$price, na.rm = TRUE)
  min_price <- min(area_data$price, na.rm = TRUE)
  max_price <- max(area_data$price, na.rm = TRUE)
  avg_reviews <- mean(area_data$number_of_reviews, na.rm = TRUE)
  
  cat("\n----------- Report for:", area_name, "-----------\n")
  cat("Total Listings:", n_listings, "\n")
  cat("Average Price:", round(avg_price, 2), "\n")
  cat("Minimum Price:", min_price, "\n")
  cat("Maximum Price:", max_price, "\n")
  cat("Average Number of Reviews:", round(avg_reviews, 2), "\n")
  cat("-----------------------------------------------\n\n")
}

generate_report(data, "Manhattan")
generate_report(data, "Brooklyn")

```
Task 5. Visualising Your Universe (Base R & ggplot2)
You have found your data (Task 3) and built tools to analyse it (Task 4). Now, you must present your findings to customers.

Your goal is to create four specific visualizations based on the real-world dataset you imported in Task 3.

Prerequisites:

Use the dataset you found and cleaned in Task 3.

Make sure library(ggplot2) is loaded.

Crucial: Every plot must have a Title, x-axis label, and y-axis label that make sense for your specific theme.

5.1. The Quick Sketch (Base R Histogram)
Sometimes you need a quick look at the distribution of your data without loading heavy packages.

Choose one numeric variable from your dataset (e.g., price, temperature, speed).

Use the hist() function from base R.

Customise the main title, xlab, and the bar col (colour).

```{r}
library(dplyr)
library(readr)
library(ggplot2)

hist(data$price,
     main = "Distribution of Airbnb Prices in NYC",
     xlab = "Price (USD per night)",
     col = "lightblue",
     border = "white")

```
5.2. The Relationship Map (ggplot2 Scatter Plot)
Now, let’s look for patterns using the industry-standard package, ggplot2.

Choose two numeric variables to see if they are correlated.

Create a scatter plot using geom_point().

Add geom_smooth() to add a relationship between variables to the plot.

Add labs() to rename your axes and title.
```{r}
ggplot(data = data, aes(x = minimum_nights, y = price)) +
  geom_point(alpha = 0.5, size = 2, colour = "blue") +
  geom_smooth(color = "gray") +
  labs(
    title = "Relationship Between Minimum Nights and Price",
    subtitle = "NYC Airbnb Listings, 2019",
    x = "Minimum Nights Required",
    y = "Price (USD per night)"
  ) +
  theme_minimal()

```
5.3. The Comparison (ggplot2 Boxplot)
The Comparison (ggplot2 Boxplot)
Boxplots are excellent for comparing groups. Let’s see how different categories in your universe perform.

Choose a categorical (or logical) variable for the X-axis (e.g., city, planet_type, species).

Choose a numeric variable for the Y-axis (e.g., price, gravity, lifespan).

Create a plot using geom_boxplot().

Bonus: Use fill to colour the boxes by the same category.

```{r}
ggplot(data = data, aes(x = neighbourhood_group, y = price, fill = neighbourhood_group)) +
  geom_boxplot() +
  labs(
    title = "Price Distribution by NYC Borough",
    x = "NYC Borough",
    y = "Price (USD per night)"
  ) +
  theme_light() +
  theme(legend.position = "none")

```
5.4. The “Deep Dive” (Faceting or Custom)
The most powerful feature of ggplot2 is faceting—creating small multiples of the same plot for different groups.

Create a plot (histogram, bar plot, or scatter plot).

Use facet_wrap(~ your_category_variable) to split the plot into a separate panel for each group in your data.

This is incredibly useful for comparing distinct groups (e.g., separate charts for each City or Year).
```{r}
ggplot(data = data, aes(x = price)) +
  geom_histogram(bins = 30, fill = "coral", color = "black") +
  facet_wrap(~ neighbourhood_group) +
  labs(
    title = "Price Distribution Across NYC Neighbourhood Groups",
    x = "Price (USD per night)",
    y = "Count"
  )

```
5.5. Final Step: Exporting (Saving Your Work)
A plot is useless if you can’t put it in a report.

Choose your favourite plot from the exercises above.

Run the code to display it in R.

Immediately run the following command to save it to your project folder:
```{r}
ggsave("nyc_airbnb_price_boxplot.png", width = 8, height = 6)

```
